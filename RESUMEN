Bases de datos 2
BDs Relacionales: 
‚óè	Utilizar un modelo de datos simple (basado en tablas y relaciones entre tablas)
‚óè	Ofrecer herramientas para garantizar la integridad de datos y la consistencia de la informaci√≥n (ACID)
‚óè	Utilizar un lenguaje de interrogaci√≥n est√°ndar, sim-ple y potente 
‚óè	Proporcionar utilidades para asegurar el acceso, manipulaci√≥n y la privacidad de los datos
‚óè	Ofrecer utilidades para la auditor√≠a y recuperaci√≥n de datos
‚óè	Garantizar la independencia del esquema l√≥gico y f√≠sico

Cual es el problema de las mismas:
‚óè	El tiempo de respuesta, especialmente si existen act√∫a-lizaciones
‚óè	Los DBMS y en especial los RDBMS utilizan el concepto de transacciones en las actualizaciones para garantizar la integridad de la informaci√≥n.
‚óè	El costo de trabajar con transacciones.
‚óè	La utilizaci√≥n de transacciones tiende a implementar ACID.
¬øY por que es necesario ACID?
‚óè	Una caracter√≠stica de las bases de datos es la reducci√≥n de la redundancia y aumento de la consistencia y la integridad de la informaci√≥n y para asegurarlo aplica ACID.

ACID
1.	Atomicidad: Se hace TODO o no se hace NADA.
2.	Consistencia: Paso de un estado consistente a otro.
3.	Aislamiento: Las operaciones que lleva a cabo una transacci√≥n durante su ciclo de vida solo son conocidas por la transacci√≥n.
4.	Durabilidad: Una vez que las operaciones son realizadas no hay posibilidad de revertirlas (A menos que sea con una nueva transacci√≥n).
Bloqueos
Un bloqueo es un mecanismo que impide las interacciones destructivas entre transacciones que acceden a un conjunto comun de datos.
Desempe√±an un papel crucial en el manejo de la concurrencia y la consistencia de la base de datos.
Existen los compartidos y los exclusivos, el primero es sobre transacciones y el 2do sobre recursos. Estos afectan a la escritura y la lectura

Deadlock: Cuando dos o mas users se quedan esperando recursos retenidos por los propios usuarios (otros)
‚ÄÉ
Granularidad: Especifica cuando la info se bloquear√° por cada operaci√≥n de bloqueo que se realice

Las BDs relacionales presentan los siguientes problemas: 
1.	Gesti√≥n de log
2.	Control de concurrencia
3.	Protocolos de transacciones distribuidas
4.	Administraci√≥n de buffers.
5.	Reglas de Integridad y Seguridad complejas.
6.	Malos dise√±os (bastante frecuente)

La soluci√≥n a todo esto fueran las BDs no relacionales, creadas por distintas empresas para solucionar sus problemas, el gran problema es que no hay un modelo que estandarice estos productos

BIG DATA:  se refiere a conjuntos de datos extremadamente grandes y complejos que requieren de t√©cnicas espec√≠ficas para su an√°lisis y procesamiento. Estos conjuntos de datos son tan grandes que las herramientas de procesamiento de datos tradicionales a menudo no son adecuadas para manejarlos.
Se basa en las 7 Vs: 
1.	VOLUMEN
2.	VELOCIDAD
3.	VARIEDAD
4.	VIABILIDAD
5.	VERACIDAD
6.	VISUALIZACION
7.	VALOR

MAP REDUCE:
MapReduce es un modelo de programaci√≥n y un paradigma de procesamiento de datos ampliamente utilizado en el √°mbito de la computaci√≥n distribuida y el procesamiento de grandes vol√∫menes de datos. 

1.	Fase Map:
En esta fase, los datos se dividen en fragmentos m√°s peque√±os llamados "splits".
Luego, se aplica una funci√≥n de mapeo (map) a cada split de datos. Esta funci√≥n toma los datos de entrada y los convierte en un conjunto de pares clave-valor.
Cada funci√≥n de mapeo produce un conjunto de resultados intermedios.
2.	Fase Shuffle y Sort:
En esta fase, los resultados intermedios se agrupan por clave. Es decir, todos los valores asociados con la misma clave se agrupan juntos.
Adem√°s, los resultados intermedios se ordenan para facilitar el proceso de reducci√≥n.

3.	Fase Reduce:
En esta fase, se aplica una funci√≥n de reducci√≥n (reduce) a cada grupo de resultados intermedios con la misma clave.
Esta funci√≥n de reducci√≥n toma la clave y todos los valores asociados con esa clave como entrada y produce un conjunto m√°s peque√±o de valores.

4.	Fase Finalizaci√≥n:
Finalmente, los resultados reducidos se escriben en almacenamiento persistente, como un sistema de archivos distribuido.

El proceso de MapReduce se ejecuta en un cl√∫ster de computadoras, donde cada nodo del cl√∫ster realiza tareas de mapeo y reducci√≥n en paralelo, lo que permite el procesamiento eficiente de grandes conjuntos de datos.

SQL VS NoSQL
Se diferencian del un RDBMS por:
‚Æö	Esquema prescindible ‚Äì no estructurado o flexible
‚Æö	Desnormalizaci√≥n
‚Æö	Escalan horizontalmente de forma natural
‚Æö	No garantizan ACID

Ventajas de SQL
‚óè	Consistencia y estructura definida
‚óè	Soporte para consultas complejas 
‚óè	Transacciones ACID
‚óè	Integridad referencial: significa que las relaciones entre diferentes tablas est√°n definidas y se mantienen autom√°ticamente.

Desventajas de SQL:
‚óè	Escala vertical limitada
‚óè	Rigidez del esquema

Ventajas de NoSQL:
‚óè	Escalabilidad horizontal
‚óè	Flexibilidad del esquema
‚óè	Alto rendimiento en operaciones de lectura y escritura

Desventajas de NoSQL:
‚óè	Falta de soporte para consultas complejas
‚óè	Consistencia eventual
‚óè	Menor madurez y soporte

Ambas son tipos de Almacenamiento Estructurado, la principal diferencia radica en c√≥mo guardan los datos.
‚Æö	En Relacional separar√≠amos la informaci√≥n en diferentes tablas y luego ejecutar√≠amos el JOIN.
‚Æö	En NoSQL se guarda la factura como una unidad, sin separar los datos.

Principios de selecci√≥n
Las BD NoSQL no siempre son la mejor soluci√≥n
Si los datos son transaccionales un RDBMS ser√≠a la opci√≥n correcta.
Las BD NoSQL son una soluci√≥n si:
‚Æö	El control transaccional ACID no es importante.
‚Æö	Los JOINs tampoco lo son. Se persigue la desnormalizaci√≥n.
‚Æö	Algunos elementos relacionales son necesarios y aconsejables como las claves (keys).
‚Æö	Necesidad de gran capacidad de escalabilidad y de replicaci√≥n en m√∫ltiples servidores (Los RDBMS tambi√©n pueden hacerlo, pero a menor escala y mayor costo operacional).

Arquitectura:
En general son de consistencia d√©bil, consistencia visual o transacciones restringidas a elementos simples de datos.
Emplean una arquitectura distribuida, con datos redundantes en varios servidores
Ofrecen arrays asociativos o estructuras clave-valor
Las consultas generalmente son por Keys o √≠ndices, y las mas complejas se hacen mediante una infraestructura de procesamiento externo

Estas bases se encuentran operativas todo el tiempo, los datos no precisan de ser consistentes todo el tiempo y por lo tanto se asegura la consistencia solo por un tiempo
‚Æö	Consistencia d√©bil ‚Äì Datos obsoletos.
‚Æö	Primero la disponibilidad
‚Æö	Respuestas aproximadas.
‚Æö	Agresivamente optimista, disponible, aunque fallen nodos.

Se aplica en:
‚Æö	Servicios Web2.0 (redes sociales, blogs, etc.)
‚Æö	Aplicaciones IoT
‚Æö	Almacenamiento de perfiles sociales
‚Æö	Juegos sociales
‚Æö	Gesti√≥n de contenidos

Ventajas
‚Æö	Masivamente escalables
‚Æö	Alta disponibilidad
‚Æö	Bajo coste comparado con soluciones similares de la misma escala
‚Æö	Elasticidad predecible
‚Æö	Esquema flexible, adecuado para datos dispersos y semi-estructurados

Inconvenientes
‚Æö	Capacidad de interrogaci√≥n limitada
‚Æö	Consistencia eventual ü°™ su programaci√≥n no es intuitiva
‚Æö	No estandarizado ü°™ no es portable
‚Æö	El desarrollo de aplicaciones clientes m√°s complejo
‚Æö	Carecen de herramientas de control de acceso (seguridad)


 
Arquitecturas de distribuci√≥n:
BDs distribuidas:  colecci√≥n de m√∫ltiples bases de datos interrelacionadas l√≥gicamente, distribuidas sobre una red de computadores y manejadas a trav√©s de un Sistema de Gesti√≥n de Bases de Datos Distribuidas
‚óè	Mezcla de tecnolog√≠as 
‚óè	Tecnolog√≠a de base de datos. 
‚óè	Tecnolog√≠a de redes y comunicaci√≥n de datos. 
‚óè	Las organizaciones ya no est√°n interesadas en bases de datos centralizadas gigantes. 
‚óè	Descentralizaci√≥n de procesos (a nivel del sistema).
‚óè	Integraci√≥n de la informaci√≥n dentro de Bases de Datos ubicadas geogr√°ficamente en distintos lugares.

 

Cluster: Grupo de servidores independientes interconectados a trav√©s de una red dedicada que trabajan como un √∫nico recurso de procesamiento.
‚óè	Ventejas:
o	Performance
o	Tolerancia a fallas
o	Distribuye la carga de servers
o	Servidor active y stand by
Escalamiento vertical:
‚óè	Escalamiento dentro de un mismo servidor
‚óè	Implica incrementar la capacidad de un Servidor 
‚óè	Es el m√°s simple y contin√∫a siendo usado hoy
‚óè	Elimina las complejidades de distribuir datos en diferentes servidores
‚óè	Algunas bases de datos suelen presentar s√≥lo la posibilidad de escalar verticalmente



Arquitectura Share Nothing:
‚óè	Es una arquitectura distribuida en la que cada nodo es independiente y autosuficiente.
‚óè	Presenta alta escalabilidad.
‚óè	Los datos se pueden repartir en muchos nodos.
‚óè	No existe SPOF (Single Point Of Failure).
Tecnolog√≠as: Grids , HADOOP

Consistencia: implica mantener la informaci√≥n uniforme mientras se mueve a lo largo de una red o varias aplicaciones.
‚óè	A nivel de bases de datos esto implica que la informaci√≥n sea v√°lida de acuerdo a reglas o modelos predefinidos

Disponibilidad:  Un sistema se define como de alta disponibilidad si garantiza respuestas para todos los requerimientos que recibe, a√∫n inclusive si uno o m√°s nodos se encuentran ca√≠dos .
Para lograr la disponibilidad de los datos en un cluster los datos deben replicarse a una cantidad de nodos, y cada nodo debe estar listo para reclamar transformarse en maestro en cualquier momento, ante la ca√≠da del mismo.

Particionamiento: Es cuando los nodos se separan f√≠sicamente y en un lapso de tiempo en el que no se pueden alcanzar por problemas varios, se lo llama ‚Äúpartici√≥n de red‚Äù.
Durante la partici√≥n los nodos deben servir para escritura y lectura


En las no SQL aparece el teorema CAP (CAP son las siglas de Consistencia ‚Äì Disponibilidad ‚Äì Particionamiento) o Consistencia Eventual
Teorema CAP: desarrollado por Eric brewer como una conjetura y formalizado en 2002 por Gilbert y Lynch en el MIT, se indicaba que era imposible tener un sistema con las 3 caracteristicas anteriores.
‚óè	El sistema debe proveer dos de los 3 antes mencionados
‚óè	Se deben tomar decisiones sobre cual de los 3 ser√° sacrificado
‚óè	Las NoSQL utilizan este tipo de enfoque

Espacio N/A:
1.	Contradice al teorema CAP
2.	No existe BD que cumpla con las 3
CA:
1.	Privilegia consistencia y disponibilidad, aparecen en las BDs relacionales y las de grafos
2.	No existe distribuci√≥n de datos, no hay partici√≥n
CP:
1.	Se privilegia tolerancia a particiones y consistencia
2.	Consistencia fuerte pero baja disponibilidad
3.	En una partici√≥n de red pueden no responder algunas consultas
AP:
1.	Alta disponibilidad y T . a particiones
2.	Estos motores ofrecen alguna forma de consistencia aunque es relativa
3.	Ofrecen replicaci√≥n de datos pero no consistencia en 2 > nodos

Parametros N, R y W:
1.	N: cantidad de nodos en cluster
2.	R: cantidad de replicaciones necesarias para que una lectura sea exitosa
3.	W: valor por defecto para un cluster completo, en algunas BD = c/u operaci√≥n de escritura
W alto = mayor consistencia, mayor falla en nodos y latencia de red
W bajo =
‚óè	menor consistencia
‚óè	 operaci√≥n exitosa con menor confirmaci√≥n por parte de los nodos
‚óè	Menos nodos por lo que hay menor tiempo de red
‚óè	Las lecturas en replicas pueden devolver datos desactualizados

R alto = alta consistencia, performance afectada, fuerza al cluster a reconciliar datos no actualizados

R bajo = Lectura menos proclive a problemas de disponibilidad y baja latencia

‚óè	Consistencia Por Escrituras
o	La consistencia por escrituras se determina por los valores W=N y R=1

o	Esta forma establece consistencia fuerte en la escritura con lo que la consistencia en la lectura est√° garantizada.

o	Modelo utilizado por los RDBMS.


o	Garantiza lecturas m√°s r√°pidas, pero lentifica las escrituras.

 
Consistencia Por Lecturas
o	La consistencia por lecturas se determina por los valores W=1 y R=N
o	Implica asegurar la escritura a un solo nodo, pero leer todos ellos.
o	Aunque pueden leerse algunos valores antiguos, se garantiza recuperar el valor m√°s reciente tambi√©n.

Consistencia Eventual
o	Si no existen nuevas actualizaciones que se hagan eventualmente a un objeto, todos los accesos van a devolver el valor m√°s actualizado en √∫ltimo t√©rmino.
o	Un ejemplo son las actualizaciones a un DNS que se distribuyen en funci√≥n a caches controlados por tiempo.
o	Eventualmente el cliente puede ver o no la actualizaci√≥n, la consistencia no est√° garantizada, aunque existen mecanismos que la intentan maximizar

Consistencia Por Quorums
o	Cuanto mayor es la cantidad de nodos que se involucran en un requerimiento, m√°s alta es la chance de evitar inconsistencias.
o	¬øCu√°ntos nodos deben estar involucrados en una operaci√≥n para obtener cierto grado deseado de consistencia?
o	Qu√≥rum de escritura: W > N/2



Bases de datos Documentales:

‚óè	Base de datos orientada a documentos o Almacenes de Documentos.

‚óè	Permite almacenar, recuperar y administrar datos estructurados o semiestructurados.

‚óè	El t√©rmino "documento" puede referirse a un documento de m√∫ltiples formatos, pero com√∫nmente es un archivo de XML o JSON.
‚óè	El esquema es variable y proporciona mucha m√°s flexibilidad para el modelado de documentos grandes
‚óè	Almacena cada registro y sus datos asociados en un solo documento conteniendo datos semiestructurados que pueden ser consultados mediante variadas herramientas de consulta.
‚óè	Los documentos se agrupan en "colecciones", que tienen un concepto similar a una tabla relacional. 
‚óè	Rendimiento de escritura r√°pido: Priorizan la escritura por sobre la consistencia
‚óè	Garantiza escrituras r√°pidas, incluso ante fallas de hardware o de la red.
‚óè	Consultas r√°pidas
Mongo DB
‚óè	Los docs en mongo son similares a un JSON
‚óè	Caracteristicas:
o	Seguridad: Autenticacion, autorizaci√≥n, encriptado, auditoria,  etc.
o	Indices: Estructuras de datos que almacenan una peque√±a porci√≥n del conjunto de datos. Puede devolver datos ordenados y permite coincidencias. El ID evita la redundancia en cierta forma
‚ñ™	Propiedades: √∫nicos, escasos, parciales, TTL
o	Replicacion: una instancia de mongod es un conjuntop de replicas. Proporciona alta disponibilidad y redundancia.


Bases de datos orientadas a objetos
Son una respuesta a los inconvenientes a la hora de persistir BDs relacionales
‚óè	Uso de estructuras de datos tan complejas como sea necesario.
‚óè	Mixean el desarrollo de aplicaciones y la gesti√≥n de datos.
‚óè	Permiten la extensibilidad con nuevos tipos de datos complejos y operaciones arbitrarias sobre ellos.
‚óè	Lograr una equivalencia al de los lenguajes de programaci√≥n orientados a objetos, como C++ o Java.
Se pueden utilizar en extensiones OO de SQL
Las BDS OO proporcionan una gesti√≥n de bases de datos orientadas a objetos a todos los niveles, desde la definici√≥n de datos al lenguaje de consulta

Ventajas:
‚óè	Mayor capacidad de modelado
‚óè	Ampliabilidad. 
‚óè	Lenguaje de consulta m√°s expresivo. 
‚óè	El acceso navegacional desde un objeto es mucho m√°s que el acceso asociativo (join sql).
‚óè	Mas adecuado para sistemas como el CAD, CASE, OIS, multimedia, etc.
Desventajas:
‚óè	Modelo de datos universal. La mayor√≠a de los productos carecen una base te√≥rica.
‚óè	Experiencia.  No hay mucha gente con experiencia en estas bds
‚óè	Est√°ndares.  No posee
‚óè	Competencia. Las RDB tienen una s√≥lida base te√≥rica y muchas herramientas de soporte.
‚óè	Encapsulamiento. 

ODMG ‚Äì Object Data Management Group
‚óè	Propone los siguientes componentes principales de la arquitectura ODMG para una OODB:
o	Modelo de objetos
o	Lenguaje de definici√≥n de objetos (ODL, Object Definition Language)
o	Lenguaje de consulta de objetos (OQL, Object Query Language)
o	Conexi√≥n con los lenguajes C++, Smalltalk y Java (al menos)

BASES DE DATOS CLAVE-VALOR

La clave:
‚óè	Identificador √∫nico que le permite acceder al valor asociado con esa clave y debe ser √∫nico.
‚óè	En teor√≠a la clave podr√≠a ser cualquier cosa.
‚óè	Productos como Redis tienen un tama√±o de clave m√°ximo permitido es 512 MB. 
‚óè	Puede usar cualquier secuencia binaria como clave.
‚óè	Por cuestiones de rendimiento se debe evitar tener una clave demasiado larga.

El valor:
‚óè	El valor puede ser cualquier cosa.
‚óè	El valor tambi√©n podr√≠a ser una lista, o incluso otro par clave-valor encapsulado en un objeto.
‚óè	En algunos se puede especificar el dato 

Ventajas:
1.	Las bases de datos clave-valor son muy efectivas en la consulta y f√°ciles de escalar. 
2.	Al no exigir ning√∫n esquema fijo, se pueden realizar modificaciones en la base de datos mientras se realizan acciones en otras entradas.
3.	Asimismo, este modelo de base de datos ofrece una gran velocidad de b√∫squeda gracias a la sencilla conexi√≥n entre la clave y el valor. 
4.	Se utilizan siempre que se requiere una alta velocidad con un gran volumen de datos.
5.	La informaci√≥n est√° dispuesta de forma clara. 

Desventajas:
1.	Solo se puede consultar un valor a trav√©s de una clave espec√≠fica, no contempla otro m√©todo de acceso. 
2.	Las b√∫squedas complejas sobre un √∫nico concepto no est√°n disponibles para recuperar por contenido.
3.	Si las b√∫squedas que involucran a mas de un concepto deben hacerse mediante programaci√≥n en alg√∫n lenguaje de programaci√≥n o de scripting (LUA). 


Cuando usarlas
1.	Almacenar informaci√≥n de sesi√≥n
2.	Perfiles de users o referencias
3.	Carros de compra

Cuando NO usarlas:
1.	Consultas que relacionen datos.
2.	Transacciones multi operaci√≥n
3.	Consulta por los valores almacenados dentro del campo valor
4.	Operaciones que abarcan diferentes conjuntos de datos

VER SI PREGUNTA ALGO CON RESPECTO A LAS CARACTERISTICAS DE REDIS

Bases de datos de grafos (NEO4J)
‚óè	Consultas que relacionen datos.
‚óè	Transacciones multi operaci√≥n
‚óè	Consulta por los valores almacenados dentro del campo valor
‚óè	Operaciones que abarcan diferentes conjuntos de datos
‚óè	Los arcos, aristas o relaciones tienen direcci√≥n.
‚óè	Los nodos est√°n vinculados por relaciones que nos permiten encontrar patrones (trabaja_en, casado_con, etc.).
‚óè	La organizaci√≥n del grafo nos permite que los datos sean almacenados una vez y luego interpretados de distintas maneras bas√°ndonos en sus relaciones

Cuando deber√≠amos usarlas:
1.	Redes sociales
2.	Recomendaciones
3.	B√∫squedas


Cuando NO:
1.	Sistemas que requieren actualizaciones masivas
2.	Sistemas que requieren de alta distribuci√≥n

Se usan por sobre las BDs relacionales ya que estas no guardan relaciones entre los datos, solo tablas con IDs

Neo4j:
‚óè	La edici√≥n de Neo4j utilizada determina el n√∫mero de posibles bases de datos:
o	Community: una sola base de datos de usuario
o	Enterprise: m√∫ltiples bases de datos de usuarios.

‚óè	Posee consistencia eventual

‚óè	Posibilidad de realizar tareas administrativas: 
o	Back up
o	Restore
o	Actualizaciones
o	Autrotizacion y autenticacion
o	Seguridad

‚óè	Ofrece monitoreo:
o	Metricas, log, consultas y transacciones, conexiones y accesos, estado del cluster y de la base de datos



1.	Seguridad: los servidores centrales proporcionan una plataforma tolerante a fallos para el procesamiento de transacciones que permanecer√° disponible mientras la mayor√≠a de los servidores centrales est√©n funcionando.

2.	Escala: las r√©plicas de lectura proporcionan una plataforma enormemente escalable para consultas de gr√°ficos que permite ejecutar cargas de trabajo de gr√°ficos muy grandes en una topolog√≠a ampliamente distribuida.

3.	Consistencia causal: cuando se invoca, se garantiza que una aplicaci√≥n cliente leer√° al menos sus propias escrituras.

Servidores centrales: Su principal responsabilidad es proteger los datos mediante replicaci√≥n de todas las transacciones (protocolo Raft).

A medida que aumentan los servidores mayor latencia tendr√° la escritura

Bases de datos tabulares

Bases de datos orientadas a columnas, almacenan los datos en bases de datos orientadas a columnas, por lo que pueden tener una cantidad muy grande de las mismas.

SON BUENAS EN
1.	Gesti√≥n de tama√±o
2.	Escrituras masivas orientadas al stream
3.	Alta disponibilidad
4.	MapReduce

Almacenan cualquier tipo de datos y pueden registrar eventos, estados de las apps y errores de las mismas

CUANDO NO USARLAS
1.	Sistema que requieren transacciones ACID para lecturas y escrituras
2.	Consultas con agregaci√≥n de datos deben hacerse del lado del cliente
3.	No es ideal para prototipos tempranos donde no haya seguridad en los patrones de consulta

Cassandra
‚óè	Esquema din√°mico: El esquema que define la estructura de los datos puede cambiar en tiempo de ejecuci√≥n. 

‚óè	No hay un √∫nico punto de fallo: Los datos se replican autom√°ticamente a varios nodos. Perder un nodo no causa la baja del cl√∫ster. 

‚óè	Alta disponibilidad

‚óè	Particionado de los datos 

‚óè	Escalabilidad horizontal: Hasta un alto n√∫mero de m√°quinas la capacidad de c√≥mputo aumenta linealmente con el n√∫mero de m√°quinas. 

‚óè	Capacidad para manejar cientos de gigabytes de datos.

ARQUITECTURA
Varios nodos independientes comunicados mediante el protocoloP2P, todos intercambian entre si informaci√≥n de manera continua
El nodo que se conecta al cliente act√∫a como coordinador entre este y el resto donde est√°n los datos afectados por consulta
El coordinador determina que nodos responden a la consulta

REPLICACION
En Cassandra, uno o m√°s nodos de un cl√∫ster act√∫an como r√©plicas de un dato dado. Si se detecta que algunos de los nodos respondieron con un valor desactualizado, Cassandra devolver√° el valor m√°s reciente al cliente.
‚óè	Nodo: es el lugar donde se almacenan los datos.

‚óè	Data Center: es una colecci√≥n de nodos relacionados.

‚óè	Cl√∫ster: un cl√∫ster es un componente que contiene uno o m√°s centros de datos.

‚óè	Commit log : el registro de confirmaci√≥n (Commit log) es un mecanismo de recuperaci√≥n de fallas en Cassandra

‚óè	MemTable: es una estructura de datos residente en la memoria. 

‚óè	SSTable: es un archivo de disco en donde se guarda el contenido de la MemTable cuando alcanza un valor determinado. 

‚óè	Filtros de Bloom: no son m√°s que algoritmos r√°pidos, no deterministas, para probar si un elemento es miembro de un conjunto. 

SEGURIDAD
‚óè	Seguridad a nivel de usuarios: logins con passwords y permisos de gesti√≥n y administraci√≥n v√≠a GRANT/REVOKE.

‚óè	Opciones de encriptaci√≥n tanto entre clientes y cl√∫steres como entre nodos.

‚óè	Ofrece varias opciones de backup. Recomendado hacerlos de forma regular ante errores como los borrados accidentales.

‚óè	Existen herramientas externas (DataStax Enterprise) que ofrecen opciones avanzadas de seguridad como ser autentificaci√≥n externa, encriptaci√≥n de tablas, y auditor√≠a de datos.

CONSISTENCIA
‚óè	Ante la posibilidad de encontrar datos inconsistentes en los nodos a pesar de tombstones, se recomienda realizar tareas rutinarias de mantenimiento; existe una operaci√≥n llamada repair, que puede utilizarse por parte del usuario para asegurar que todos los nodos son consistentes

Estructura de datos
‚óè	Columna (Columns): unidad b√°sica de almacenamiento. Consistente en una estructura de tres valores: name, value y timestamp.
‚óè	Filas o entradas (Rows): conjunto de columnas de una familia con valor asignado.
‚óè	Familia de Columnas (ColumnFamilies): contenedor de m√∫ltiples columnas. Es equivalente a una tabla en el modelo relacional.
‚óè	Keyspace: es la agrupaci√≥n de Familia de Columnas, normalmente hay un keyspace por aplicaci√≥n.
‚óè	Cl√∫ster: las m√°quinas (nodos) de una instancia de Cassandra. 


BIG DATA ‚Äì HADOOP
‚óè	Conjunto de tecnolog√≠as que han sido creadas para recopilar, analizar y gestionar los datos que generan los usuarios. 

‚óè	Su idea es la de recopilar los datos masivos que son generados en "bruto", y procesarlos para identificar patrones u otro tipo de comportamientos que puedan ayudar a sectores concretos.

Hadoop:
‚óè	Hadoop b√°sicamente tiene dos componentes principales. 

a.	El primero es un sistema de archivos distribuido Hadoop (HDFS) para el almacenamiento de informaci√≥n distribuida.

b.	La segunda parte es MapReduce para procesamiento distribuido. 

1.	Almacenar y procesar grandes cantidades de cualquier tipo de dato
2.	Procesamiento
3.	Tolerancia a fallos
4.	Flexibilidad
5.	Bajo coste
6.	Escalabilidad

MAP REDUCE: componente de procesamiento de hadoop
MAP: basado en divide y conquista
Reduce: combina y reduce la cardinalidad, recoge las respuestas en cadas subnodo y las combina en un resultado final



